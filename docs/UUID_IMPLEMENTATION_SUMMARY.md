# Deterministic UUID Implementation Summary

## What Changed

Changed from **random UUIDs** to **deterministic UUIDs** based on recipe title + source_url.

## Why Deterministic UUIDs?

### Before (Random UUIDs)
```python
uuid: str = Field(default_factory=lambda: str(uuid.uuid4()))
```
- ❌ Same recipe from different runs gets different UUIDs
- ❌ No automatic deduplication
- ❌ Reprocessing creates duplicates

### After (Deterministic UUIDs)
```python
uuid = generate_recipe_uuid(title, source_url)
# or
uuid = generate_reddit_recipe_uuid(title, reddit_post_id)
```
- ✅ Same recipe from same source = **same UUID**
- ✅ Automatic deduplication
- ✅ Idempotent processing

## Files Modified

### 1. New Utility Module
**`src/recipes/utils/uuid_utils.py`** (NEW)
- `generate_recipe_uuid(title, source_url)` - Main UUID generation function
- `generate_reddit_recipe_uuid(title, reddit_post_id)` - Reddit-specific variant
- Uses UUID v5 (namespace-based) for deterministic generation

### 2. Recipe Model
**`src/recipes/models/recipe.py`**
- Changed `uuid` from auto-generated to optional
- Removed random UUID generation
- UUID now generated by RecipeService

### 3. Recipe Service
**`src/recipes/services/recipe_service.py`**
- Added UUID generation logic in `create()` method
- Automatically generates UUID based on:
  - Reddit recipes: `title + reddit:{post_id}`
  - Other recipes: `title + source_url`
  - No source: `title` only

### 4. Database Migration
**`db/migrations/001_add_recipe_uuid.sql`**
- Creates PostgreSQL function `generate_recipe_uuid()`
- Backfills deterministic UUIDs for existing recipes
- Enables `uuid-ossp` extension for `uuid_generate_v5()`

### 5. Documentation
- **`docs/UUID_TRACKING.md`** - Complete guide updated with deterministic approach
- **`CHANGELOG.md`** - Added deterministic UUID feature details
- **`docs/UUID_IMPLEMENTATION_SUMMARY.md`** - This file

## UUID Generation Logic

### Algorithm
1. Normalize title: `LOWER(TRIM(title))`
2. Normalize source: `LOWER(TRIM(source_url))` or `''`
3. Combine: `"{title}:{source}"`
4. Generate: `uuid.uuid5(namespace, content)`

### Examples

#### Reddit Recipe
```python
title = "Soy Braised Beef"
reddit_post_id = "t3_1abc123"
source = f"reddit:{reddit_post_id}"

# Normalized: "soy braised beef:reddit:t3_1abc123"
# UUID: Deterministic based on above string
```

#### Recipe with Source URL
```python
title = "Chocolate Chip Cookies"
source_url = "https://example.com/recipes/cookies"

# Normalized: "chocolate chip cookies:https://example.com/recipes/cookies"
# UUID: Deterministic based on above string
```

#### Recipe without Source
```python
title = "Grandma's Secret Recipe"
source_url = None

# Normalized: "grandma's secret recipe:"
# UUID: Deterministic based on title only
```

## Deduplication Behavior

### Scenario 1: Same Recipe, Same Source
```python
# First run
recipe1 = Recipe(title="Cookies", source_url="https://site.com/recipe1")
await RecipeService.create(recipe1)
# UUID: abc-123-def

# Second run (reprocessing)
recipe2 = Recipe(title="Cookies", source_url="https://site.com/recipe1")
await RecipeService.create(recipe2)
# UUID: abc-123-def (SAME!)
# Database UNIQUE constraint: Insert fails, no duplicate created ✅
```

### Scenario 2: Same Recipe, Different Source
```python
# From Source A
recipe1 = Recipe(title="Cookies", source_url="https://siteA.com/recipe")
await RecipeService.create(recipe1)
# UUID: abc-123-def

# From Source B
recipe2 = Recipe(title="Cookies", source_url="https://siteB.com/recipe")
await RecipeService.create(recipe2)
# UUID: xyz-789-ghi (DIFFERENT!)
# Two different recipes in database ✅
```

### Scenario 3: Same Reddit Recipe, Multiple Runs
```python
# First scrape
recipe1 = Recipe(title="Pizza", reddit_post_id="t3_abc")
await RecipeService.create(recipe1)
# UUID: def-456-ghi

# Later rescrape (scheduled job)
recipe2 = Recipe(title="Pizza", reddit_post_id="t3_abc")
await RecipeService.create(recipe2)
# UUID: def-456-ghi (SAME!)
# No duplicate created ✅
```

## Migration Required

The database migration regenerates UUIDs for all existing recipes:

```bash
# Apply migration
./scripts/setup/apply_uuid_migration.sh

# Or manually
psql -U postgres -d recipes -f db/migrations/001_add_recipe_uuid.sql
```

**Important**: After migration:
1. All existing recipes get new deterministic UUIDs
2. Elasticsearch needs reindexing: `python -m recipes.cli sync-search --recreate-index`

## Testing UUID Generation

```python
from recipes.utils.uuid_utils import generate_recipe_uuid

# Test deterministic behavior
uuid1 = generate_recipe_uuid("Test Recipe", "https://example.com")
uuid2 = generate_recipe_uuid("Test Recipe", "https://example.com")
assert uuid1 == uuid2  # Passes! ✅

# Test different sources produce different UUIDs
uuid3 = generate_recipe_uuid("Test Recipe", "https://other.com")
assert uuid1 != uuid3  # Passes! ✅

# Test case insensitivity
uuid4 = generate_recipe_uuid("TEST RECIPE", "HTTPS://EXAMPLE.COM")
assert uuid1 == uuid4  # Passes! (normalized) ✅
```

## Benefits

1. **Automatic Deduplication** - Same recipe = same UUID = database constraint prevents duplicates
2. **Idempotent ETL** - Reprocessing same data doesn't create duplicates
3. **Consistent Tracking** - Same UUID across system restarts
4. **Predictable** - Can calculate expected UUID for debugging
5. **Pipeline Resilience** - Restarting workflows doesn't lose track of recipes

## Backward Compatibility

⚠️ **Breaking Change**: Existing recipes will get new UUIDs after migration.
- Database IDs remain unchanged
- Only UUIDs change to deterministic values
- Client will show new UUIDs after Elasticsearch resync

